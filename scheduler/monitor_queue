#!/usr/bin/python -u
# monitor_queue <client> <spool_directory> <resultsdir> [<conmux_server>]
import os, time, sys
from subprocess import *
import tempfile

if (len(sys.argv) < 3):
    print "Usage: monitor_queue <spool_directory> <resultsdir> [<conmux_server>]"
    sys.exit(1)
(spooldir, resultsdir) = [os.path.abspath(p) for p in sys.argv[1:3]]

queue_name = os.path.basename(spooldir)
dotmachines = os.path.join(spooldir, '.machines')
if os.path.exists(dotmachines):
    machines = [l.strip() for l in open(dotmachines).readlines() if len(l.strip())]
else:
    print "No .machines file in %s, assuming queue name is a machine"\
                                                             % queue_name
    machines = [queue_name]

if len(sys.argv) == 5:
    console = sys.argv[4]
else:
    console = None
if not os.path.exists(spooldir):
    print "spooldir %s does not exist" % spooldir
    sys.exit(1)
if not os.path.exists(resultsdir):
    print "resultsdir %s does not exist" % resultsdir
    sys.exit(1)


##### Control file templates #####
SERV_MULTI = """# monitor_queue generated autoserv file (SERV_MULTI template)
hosts = [hosts.SSHHost(hostname, server=%s)
                for hostname in machines]

at = autotest.Autotest()

control_path = %s
results = %s

def install_run(host):
        at.install(host)
        host_results = os.path.join(results, host.hostname)
        at.run(control_path, host_results, host)

parallel([subcommand(install_run, [host]) for host in hosts])"""


SERV_SINGLE = """# monitor_queue generated autoserv file (SERV_SINGLE template)
host = hosts.SSHHost(machines[0], server=%s)

at = autotest.Autotest()

control_path = %s
results = %s

at.install(host)
at.run(control_path, results, host)"""

##### End control file templates #####

def pick_job(jobs):
    """Pick the next job to run. Currently we just pick the oldest job
    However, this would be the place to put prioritizations."""
    if not jobs:
        return None
    return sorted(jobs, key=lambda x:os.stat(x).st_mtime, reverse=True)[0]


def __create_autoserv_wrapper(template, control_path, results):
    """Create an autoserv file that runs an autotest file at
    control_path on clients and outputs the results in results."""
    # Create an autoserv control file to run this autotest control file
    tmpfd, tmpname = tempfile.mkstemp()
    tmp = os.fdopen(tmpfd, 'w')

    print >> tmp, template % tuple([repr(s) for s in (console,
                                                      control_path,
                                                      results)])
    return tmpname


def run_job(control, queuename, scheduler_dir):
    """Runs a control file from the spooldir.
    Args:
      control: A path to a control file.  It is assumed to be an
        Autotest control file in which case it will automatically
        be wrapped with autoserv control commands and run with
        autoserv.  If the file name ends with .srv the wrapping
        procedure will be skipped and the autoserv file will be
        run directly.

    Return:
      The return code from the autoserv process.
    """
    # Make sure all the output directories are all setup
    results = os.path.join(resultsdir, queuename + '-' + control)
    if os.path.exists(results):
        print "Resultsdir %s already present, " % results,
        results = "%s.%d" % (results, int(time.time()))
        print "changing to %s" % results
    os.mkdir(results)
    debug = os.path.join(results, 'debug')
    os.mkdir(debug)

    # If this is an autoserv file then don't create the wrapper control
    is_autoserv_ctl = control.endswith('.srv')
    control_path = os.path.abspath(os.path.join(spooldir, control))
    # Otherwise create a tmp autoserv file just to launch the AT ctl file
    if not is_autoserv_ctl:
        if len(machines) > 1:
            # Run autotest file on *all* machines in *parallel*
            template = SERV_MULTI
        else:
            # Run autotest file on *one* machine
            template = SERV_SINGLE
        control_path = __create_autoserv_wrapper(template,
                                                 control_path,
                                                 results)

    # Now run the job
    autoserv_exe = os.path.join(scheduler_dir, '..', 'server', 'autoserv')
    autoserv_exe = os.path.abspath(autoserv_exe)

    autoserv_cmd = ' '.join([autoserv_exe, '-m', ','.join(machines),
                                                             control_path])

    print "Starting job: %s" % control
    print autoserv_cmd

    open(os.path.join(debug, 'autoserv.cmd'), 'w', 0).write(autoserv_cmd + '\n')
    autoserv_stdout = open(os.path.join(debug, 'autoserv.stdout'), 'w', 0)
    autoserv_stderr = open(os.path.join(debug, 'autoserv.stderr'), 'w', 0)
    p = Popen(autoserv_cmd, shell=True, stdout=autoserv_stdout,
                                        stderr=autoserv_stderr, cwd=results)
    (pid, ret) = os.waitpid(p.pid, 0)
    autoserv_stdout.close()
    autoserv_stderr.close()

    # If this was a tempfile then clean it up
    if not is_autoserv_ctl:
        os.unlink(control_path)
    print "Completed job: %s (%d) " % (control, ret)

    return ret


scheduler_dir = os.path.dirname(os.path.abspath(sys.argv[0]))
os.chdir(spooldir)
print "monitoring spool directory: " + spooldir
while True:
    jobs = [j for j in os.listdir(spooldir) if not j.startswith('.')]
    next_job = pick_job(jobs)
    if not next_job:
        time.sleep(10)
        continue
    ret = run_job(next_job, os.path.basename(spooldir), scheduler_dir)
    os.remove(next_job)
