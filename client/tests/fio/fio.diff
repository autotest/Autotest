--- src/Makefile.old	2006-09-26 23:01:44.000000000 -0700
+++ src/Makefile	2006-09-26 23:02:35.000000000 -0700
@@ -1,12 +1,12 @@
 CC	= gcc
-CFLAGS	= -Wall -O2 -g -D_GNU_SOURCE -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64
+CFLAGS	+= -Wall -O2 -g -D_GNU_SOURCE -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64
 PROGS	= fio
 SCRIPTS = fio_generate_plots
 
 all: depend $(PROGS) $(SCRIPTS)
 
 fio: fio.o ioengines.o init.o stat.o log.o time.o md5.o crc32.o
-	$(CC) $(CFLAGS) -o $@ $(filter %.o,$^) -lpthread -laio -lm -lrt
+	$(CC) $(CFLAGS) $(LDFLAGS) -o $@ $(filter %.o,$^) -lpthread -laio -lm -lrt
 
 clean:
 	-rm -f *.o .depend cscope.out $(PROGS)
diff -uprN trunk/tests/fio/2.6.18+kernel-headers.patch autotest/tests/fio/2.6.18+kernel-headers.patch
--- trunk/tests/fio/2.6.18+kernel-headers.patch	1970-01-01 01:00:00.000000000 +0100
+++ autotest/tests/fio/2.6.18+kernel-headers.patch	2006-10-05 14:06:19.000000000 +0200
@@ -0,0 +1,64 @@
+If you have a new kernel headers (2.6.18+), you will need this patch
+
+From: Jens Axboe <jens.axboe@oracle.com>
+
+diff --git a/os-linux.h b/os-linux.h
+index fd5356b..4c54c8c 100644
+--- a/os-linux.h
++++ b/os-linux.h
+@@ -5,6 +5,7 @@ #include <sys/ioctl.h>
+ #include <sys/uio.h>
+ #include <sys/syscall.h>
+ #include <unistd.h>
++#include <fcntl.h>
+ #include <linux/unistd.h>
+
+ #define FIO_HAVE_LIBAIO
+@@ -39,33 +40,35 @@ static inline int ioprio_set(int which,
+ 	return syscall(__NR_ioprio_set, which, who, ioprio);
+ }
+
+-static _syscall6(int, sys_splice, int, fdin, loff_t *, off_in, int, fdout, loff_t *, off_out, size_t, len, unsigned int, flags);
+-static _syscall4(int, sys_vmsplice, int, fd, const struct iovec *, iov, unsigned long, nr_segs, unsigned int, flags);
+-static _syscall4(int, sys_tee, int, fdin, int, fdout, size_t, len, unsigned int, flags);
++/*
++ * Just check for SPLICE_F_MOVE, if that isn't there, assume the others
++ * aren't either.
++ */
++#ifndef SPLICE_F_MOVE
++#define SPLICE_F_MOVE	(0x01)	/* move pages instead of copying */
++#define SPLICE_F_NONBLOCK (0x02) /* don't block on the pipe splicing (but */
++				 /* we may still block on the fd we splice */
++				 /* from/to, of course */
++#define SPLICE_F_MORE	(0x04)	/* expect more data */
++#define SPLICE_F_GIFT   (0x08)  /* pages passed in are a gift */
+
+ static inline int splice(int fdin, loff_t *off_in, int fdout, loff_t *off_out,
+ 			 size_t len, unsigned long flags)
+ {
+-	return sys_splice(fdin, off_in, fdout, off_out, len, flags);
++	return syscall(__NR_sys_splice, fdin, off_in, fdout, off_out, len, flags);
+ }
+
+ static inline int tee(int fdin, int fdout, size_t len, unsigned int flags)
+ {
+-	return sys_tee(fdin, fdout, len, flags);
++	return syscall(__NR_sys_tee, fdin, fdout, len, flags);
+ }
+
+ static inline int vmsplice(int fd, const struct iovec *iov,
+ 			   unsigned long nr_segs, unsigned int flags)
+ {
+-	return sys_vmsplice(fd, iov, nr_segs, flags);
++	return syscall(__NR_sys_vmsplice, fd, iov, nr_segs, flags);
+ }
+-
+-#define SPLICE_F_MOVE	(0x01)	/* move pages instead of copying */
+-#define SPLICE_F_NONBLOCK (0x02) /* don't block on the pipe splicing (but */
+-				 /* we may still block on the fd we splice */
+-				 /* from/to, of course */
+-#define SPLICE_F_MORE	(0x04)	/* expect more data */
+-#define SPLICE_F_GIFT   (0x08)  /* pages passed in are a gift */
++#endif
+
+ #define SPLICE_DEF_SIZE	(64*1024)


