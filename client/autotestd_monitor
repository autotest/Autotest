#!/usr/bin/python
"""
Watches the execution of autotestd, printing the logfiles to stdout and stderr.
"""
import sys, os, signal, time, fcntl, threading

class AutotestdMonitorTimeoutError(Exception):
    """
    Exception thrown when autotestd cannot start after a given timeout.
    """
    def __init__(self, logdir, timeout):
        self.logdir = logdir
        self.timeout = timeout

    def __str__(self):
        return ("Autotestd monitor failed to start on %s after %d s" %
                (self.logdir, self.timeout))


def launch_tail(path, outstream, start):
    """
    Watches the given path printing the result to outstream.

    @param path: Path that will be watched.
    @param outstream: Output stream (sys.stdout, for example).
    @param start: Skip [start] bytes from output.
    """
    global _thread_termination_event
    while not os.path.isfile(path):
        time.sleep(0.1)
    log_file = open(path, 'r')
    log_file.seek(start)
    while True:
        where = log_file.tell()
        line = log_file.readline()
        if not line:
            log_file.seek(where)
        else:
            outstream.write(line)
        if _thread_termination_event.isSet():
            break
        _thread_termination_event.wait(1)


if __name__ == "__main__":
    logdir = sys.argv[1]
    stdout_start = int(sys.argv[2])  # number of bytes we can skip on stdout
    stderr_start = int(sys.argv[3])  # nubmer of bytes we can skip on stderr
    autotestd_monitor_timeout = 30   # monitor timeout

    stdout_file_path = os.path.join(logdir, 'stdout')
    stderr_file_path = os.path.join(logdir, 'stderr')

    _thread_termination_event = threading.Event()
    _stdout_thread = threading.Thread(target=launch_tail,
                                      args=(stdout_file_path, sys.stdout,
                                            stdout_start))
    _stderr_thread = threading.Thread(target=launch_tail,
                                      args=(stderr_file_path, sys.stderr,
                                            stderr_start))
    _stdout_thread.start()
    _stderr_thread.start()

    # wait for logdir/started to exist to be sure autotestd is started
    start_time = time.time()
    started_file_path = os.path.join(logdir, 'started')
    while not os.path.exists(started_file_path):
        time.sleep(1)
        time_elapsed = time.time() - start_time
        if time_elapsed >= autotestd_monitor_timeout:
            raise AutotestdMonitorTimeoutError(logdir,
                                               autotestd_monitor_timeout)

    # watch the exit code file for an exit
    exit_code_file = open(os.path.join(logdir, 'exit_code'))
    fcntl.flock(exit_code_file, fcntl.LOCK_EX)
    try:
        exit_code = exit_code_file.read()
        if len(exit_code) != 4:
            exit_code = -signal.SIGKILL   # autotestd was nuked
        else:
            exit_code = int(exit_code)
    finally:
        fcntl.flock(exit_code_file, fcntl.LOCK_UN)
        exit_code_file.close()

    _thread_termination_event.set()
    _stdout_thread.join(2)
    _stderr_thread.join(2)

    # exit (with the same code as autotestd)
    sys.exit(exit_code)
