#!/usr/bin/python
import os, re, parse, frontend, db, sys, socket, getopt
from traceback import format_exception

usage = """\
usage: parse
	[-m]                           # Send mail for FAILED tests
	[-o directory]                 # Specify results directory directly
	<top level results directory>  # Specify top level results directory
"""

def format_error():
	t, o, tb = sys.exc_info()
	trace = format_exception(t, o, tb)
	# Clear the backtrace to prevent a circular reference
	# in the heap -- as per tutorial
	tb = ''

	return ''.join(trace)


try:
	opts, args = getopt.getopt(sys.argv[1:], "hmo:", ["help"])
except getopt.GetoptError:
	# print help information and exit:
	usage()
	sys.exit(2)

if len(sys.argv) < 2:
	print usage
	sys.exit(2)

singledir = None
mailit = False
for name, value in opts:
	if name in ("-h", "--help"):
		usage()
		sys.exit()
	if name == "-m":
		mailit = True
	if name in ("-o", "--output"):
		singledir = value


if singledir:
	dir = os.path.abspath(singledir)
	jobs_list = [(os.path.basename(dir), dir)]
else:
	topdir = os.path.abspath(args[0])
	jobs_list = [(dir, os.path.join(topdir, dir)) for dir in os.listdir(topdir)]

debug = True

failcc = ""
notify_user = None

db = db.db(autocommit=False)  # do commits transactionally


def mailfailure(jobname, job, mesgtxt):
	# XXX: Need to insert URL here too (frontend.test.url?)
	link = "http://" + socket.gethostname() + "/results/" + jobname

	# This looks pretty good on fixed-width-font email reader.
	message_header = "\n%s\n%s\n\n%-12s %-20s %-12s %-10s %s\n" % ("The following tests FAILED for this job:", link, "Job name", "Kernel", "Test name", "FAIL/WARN", "Failure Reason")
	message_header += "%-12s %-20s %-12s %-10s %s\n" % ("========", "======", "=========", "=========", "==============")

	subject = "AUTOTEST: FAILED tests from " + " job " + jobname
	parse.mail(notify_user, job.user, failcc, subject, message_header + mesgtxt)


def do_parse(jobname, path):
	if debug:
		print '\nScanning' + path
	if db.find_job(jobname):              # Job has already been parsed
		if debug:
			print '! Already processed'
		return
	job = parse.job(path, 'regression')
	if not job:
		if debug:
			print '! Not a job'
		return
	print '+ Parsed ' + path
	if not job.kernel:
		if debug:
			print '! Not a job.kernel'
		return
	print '* jobname, kernel version: %s %s' % (jobname, job.kernel.base)
	mesgtxt = "\n"
	for test in job.tests:
		if not test.subdir:
			continue
		print "* testname, status, reason: %s %s %s" % (test.subdir, test.status, test.reason)
		if re.match(r'(FAIL|WARN)',test.status):
			mesgtxt += "%-12s %-20s %-12s %-10s %s" % (jobname, job.kernel.base, test.subdir, test.status, test.reason)

	if len(mesgtxt) > 2 and mailit:
		print "Sending email report of FAILURES on " + jobname + " to " + job.user
		mailfailure(jobname, job, mesgtxt)
	db.insert_job(jobname, job)
	print "COMMITING"
	db.commit()



for (jobname, path) in jobs_list:
	machine_list = os.path.join(path, '.machines')
	if os.path.exists(machine_list):
		for m in open(machine_list, 'r').readlines():
			machine = m.rstrip()
			if not machine:
				continue
			jobpath = os.path.join(path, machine)
			jobname = os.path.join(os.path.basename(path), machine)
			try:
				do_parse(jobname, jobpath)
			except:
				print format_error()
				continue
	else:
		try:
			do_parse(jobname, path)
		except:
			print format_error()
			continue


# rows = db.select('distinct hostname', 'machines', {})
# machines = [row[0] for row in rows]
# 
# for machine in machines:
# 	dir = os.path.dirname(os.path.abspath(sys.argv[0]))
# 	vertical_text = os.path.join(dir, 'vertical_text.py')
# 	os.system(vertical_text + ' ' + machine)
