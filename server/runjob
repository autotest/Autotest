#!/usr/bin/python
import sys, os, re, commands, time
from subprocess import *

# Execute a job on a remote client. We use ssh to connect.
#
# autotest-client is run on the other end. It will connect us with
# stdout and stderr outputs:
#
# stdout: standard output of autotest binary (job spew)
# stderr: Control stream (read from named pipe on client
#
# We want to just log stdout to a server-side file.
# Stderr is what we're monitoring closely for status.
# If the stderr stream gives us an EOF, the autotest-client exited

# Return codes:
# 0 - success
# 1 - verify machine failed
# 2 - execute job failed

autodir = '/usr/local/autotest'            # default. changed by retrieve_config

def parse_arguments():
	# First parse arguments, do setup, etc.
	if len(sys.argv) < 4:
		sys.stderr.write("Usage: runjob <client> <control_file> <results>\n")
		sys.exit(1)
	(client, control, results) = sys.argv[1:4]
	if not os.path.exists(control):
		sys.stderr.write("Control file %s does not exist\n" % control)
		sys.exit(1)
	return (client, control, results)


def retrieve_config(client):
	# Grab the autotest.conf file from the client, 
	# so we can use config information
	print "Retrieving autotest.conf from %s" % client
	local_conf = "/tmp/autotest.conf.%d" % os.getpid()
	if os.path.exists(local_conf):
		system("rm -f %s" % local_conf)
	os.system("scp -q root@%s:/etc/autotest.conf %s" % (client, local_conf))

	# Now to find out what $AUTODIR is on the client
	# This is disgusting, but will have to do for now. 
	# We can't source it (security nightmare)
	global autodir
	for line in open(local_conf, 'r').readlines():
		dir = re.search(r'autodir=(\S+)', line).group(1)
		if dir:
			autodir = re.sub('[\'\"]', '', dir)
	print "autodir set to " + autodir


def verify_machine(client):
	autotest_bin = os.path.join(autodir, 'bin/autotest')
	ret = os.system("ssh -q root@%s ls %s > /dev/null" % (client, autotest_bin))
	if ret != 0:
		return False
	return True
	

def push_control(remote_control):
	# Push the control file we want to sue to the client
	print "Pushing control file %s to %s" % (control, client)
	ret = os.system("scp -q %s root@%s:%s" % \
					(control, client, remote_control))
	if ret != 0:
		raise "pushing control file failed"


def execute_section(client, autodir, remote_control, section):
	print "Executing %s/bin/autotest %s/control phase %d" % \
						(autodir, autodir, section)
	client_log = open("%s/debug/client.log.%d" % (results, section), 'w')
	if section > 0:
		remote_control = '-c ' + remote_control
	cmd = "ssh -q root@%s %s/bin/autotest_client %s" % \
					(client, autodir, remote_control)
	# for line in Popen(cmd, shell=True, stdout=client_log, stderr=PIPE).stderr:
	# 	print line,
	#	sys.stdout.flush()
	f = Popen(cmd, shell=True, stdout=client_log, stderr=PIPE).stderr
	line = f.readline()
	while line:
		last = line
		print line,
		sys.stdout.flush()
		line = f.readline()
	return last


def execute_control(client, autodir, remote_control):
	section = 0
	while True:
		last = execute_section(client, autodir, remote_control, section)
		section += 1
		if re.match('DONE', last):
			print "Client complete"
			return True
		elif re.match('REBOOT', last):
			print "Client is rebooting"
			time.sleep(300)
		else:
			sys.stderr.write("Aborting - unknown return code: %s\n"\
									 % last)
			return False


def retrieve_results(client, autodir, results):
	ret = os.system("scp -rq root@%s:%s/results/default/* %s" % \
						(client,autodir,results))
	if ret != 0:
		raise "retrieve results failed"


# MAIN PROGRAM

ret = 0
(client, control, results) = parse_arguments()
debug = os.path.join(results, 'debug')
if not os.path.exists(debug):
	os.makedirs(debug)

retrieve_config(client)
if not verify_machine(client):
	sys.exit(1)
remote_control = "%s/control" % autodir
push_control(remote_control)
if not execute_control(client, autodir, remote_control):
	ret = 2
retrieve_results(client, autodir, results)
sys.exit(ret)
