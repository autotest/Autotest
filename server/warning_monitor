#! /usr/bin/expect
#
# console-monitor - monitor a machine console for events
#
# Watch the console output for this machine.  Generate events
# for anything we deem 'interesting'.  stderr is the event channel.
#
# (C) Copyright IBM Corp. 2006, 2007
# Author: Andy Whitcroft <andyw@uk.ibm.com>
#
# This file is released under the GNU Public License V2

#
#
set P "console-monitor"
log_user 0
##exp_internal 1
##match_max 65536

#
# We take the machine name _purely_ so that we can identify this
# console monitor.  We are already connected to the machine thanks
# to conmux-attach.
#
if {$argc != 1} {
       puts stderr "Usage: $P <machine>"
       exit 1
}

proc note {msg} {
       global P
       puts stderr "$P: $msg"
}
proc warn {msg} {
       global P
       puts stderr "$P: $msg"
       puts "~\$msg $msg"
}

proc raw_event {msg} {
       puts stderr "$msg"
}
proc event {msg} {
       raw_event "CONMON-EVENT $msg"
}
proc alert {msg} {
       event $msg
       raw_event "CONMON-ALERT $msg"
}
proc status {msg} {
       event $msg
       raw_event "CONMON-STATUS $msg"
}

event "CONMON starting"

set timeout -1
set restart_time 0
set login_report 0
expect_user {
       -re {^[^\n]*(Rebooting...|Restarting system.)} {
               if {[clock seconds] > ($restart_time + 60)} {
                       event "machine restarting"
                       set restart_time [clock seconds]
               }
               exp_continue
       }

       -re {^[^\n]*boot:} {
               event "bootloader (lilo/yaboot) started"
               exp_continue
       }
       -re {^[^\n]*(GRUB  version|GNU GRUB)} {
               event "bootloader (grub) started"
               exp_continue
       }

       -re {^\s*Linux version } {
               event "kernel started"
               exp_continue
       }
       -re {^[^\n]*INIT: version .* booting} {
               event "machine reached init"
               set login_report 1
               exp_continue
       }
       -re {^[^\n]*login:} {
               if { $login_report == 1 } {
                       event "machine reached login"
                       set login_report 0
               }
               exp_continue
       }

       -re {^[^\n]*Oops: umount failed} {
               exp_continue
       }

       -re {^[^\n]*Kernel panic} {
               alert "machine panic'd (see console)"
               exp_continue
       }
       -re {^[^\n]*Oops} {
               alert "machine Oops'd (see console)"
               exp_continue
       }
       -re {^[^\n]*kdb>} {
               alert "machine dropped to kdb (see console)"
               exp_continue
       }
       -re {^[^\n]*Open Firmware exception handler entered from non-OF code} {
               alert "machine took an open firmware exception (see console)"
               exp_continue
       }
       -re {^[^\n]*(BUG:[^\n]*)} {
               alert "$expect_out(1,string) (see console)"
               exp_continue
       }
       -re {^[^\n]*(kernel BUG [^\n]*)} {
               alert "$expect_out(1,string) (see console)"
               exp_continue
       }
       -re {^[^\n]*(invoked oom-killer:[^\n]*)} {
               alert "$expect_out(1,string) (see console)"
               exp_continue
       }

       -re {^[^\n]*(MACHINE ERROR:[^\n]*)} {
               status "ERROR $expect_out(1,string) (see console)"
               exp_continue
       }

       -re {^[^\n]*TEST;} {
               warn "test trigger detected"
               exp_continue
       }
       -re "^\[^\n]*\n" {
               ##puts "<<<$expect_out(buffer)>>>"
               exp_continue
       }
}
