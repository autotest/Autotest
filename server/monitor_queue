#!/usr/bin/python -u
# monitor_queue <client> <spool_directory> <resultsdir> [<conmux_console>]
import os, time, sys
from subprocess import *

if (len(sys.argv) < 4):
	print "Usage: monitor_queue <client> <spool_directory> <resultsdir> [<conmux_console>]"
	sys.exit(1)
(client, spooldir, resultsdir) = sys.argv[1:4]
if len(sys.argv) == 5:
	console = sys.argv[4]
else:
	console = None
if not os.path.exists(spooldir):
	print "spooldir %s does not exist" % spooldir
	sys.exit(1)
if not os.path.exists(resultsdir):
	print "resultsdir %s does not exist" % resultsdir
	sys.exit(1)


def pick_job(jobs):
	# Pick the next job to run. Currently we just pick the oldest job
	# However, this would be the place to put prioritizations.
	if not jobs:
		return None
	return sorted(jobs, key=lambda x:os.stat(x).st_mtime, reverse=True)[0]


def run_job(control):
	print "Executing job: " + next_job

	# First set up some paths.
	results = os.path.join(resultsdir, next_job)
	if os.path.exists(results):
		print "Resultsdir %s already present, " % results,
		results = "%s.%d" % (results, int(time.time()))
		print "changing to %s" % results
	os.mkdir(results)
	debug = os.path.join(results, 'debug')
	os.mkdir(debug)

	# Now run the job
	runjob_cmd = ' '.join([runjob, client, next_job, results])
	if console:
		runjob_cmd += ' ' + console
	server_log = open(os.path.join(debug, 'server.log'), 'w');
	p = Popen(runjob_cmd, shell=True, stdout=server_log, stderr=STDOUT)
	(pid, ret) = os.waitpid(p.pid, 0)
	file.close(server_log)
	print "Completed job: %s (%d) " % (next_job, ret)
	return ret


dir = os.path.abspath(os.path.dirname(sys.argv[0]))
runjob = os.path.join(dir, 'runjob')
os.chdir(spooldir)
print "monitoring spool directory: " + spooldir
while True:
	jobs = [j for j in os.listdir(spooldir) if not j.startswith('.')]
	next_job = pick_job(jobs)
	if not next_job:
		time.sleep(10)
		continue
	ret = run_job(next_job)
	if ret == 1:          # Ooops. the machine is stuffed.
		print "WARNING: client %s failed verify_machine" % client
		sleep(600)
		continue
	os.remove(next_job)
