#!/usr/bin/python2.3
#
# autotest <control file> - run the autotest control file specified.
#
import os, sys, shutil
import job, kernel, test
from error import *
from autotest_utils import *

# Use the name of the binary to find the real installation directory
# aka $AUTODIR.  Update our path to include the $AUTODIR/bin/tests
# directory and ensure we have $AUTODIR in our environment.
autodirbin = os.path.abspath(os.path.dirname(sys.argv[0]))
autodir = os.path.dirname(autodirbin)

##print 'AUTODIRBIN: ' + autodirbin
##print 'AUTODIR: ' + autodir

sys.path.insert(0, autodir + '/tests')
sys.path.insert(0, autodirbin)

os.environ['AUTODIR'] = autodir
os.environ['AUTODIRBIN'] = autodirbin

# If we are envoked with a control file, clear up any old control file
# and start that. 
tmp_control_file = autodir + '/control'
if (len(sys.argv) != 1):
	if os.path.exists(tmp_control_file):
		os.remove(tmp_control_file)
	# XXX: we need to know about the state file ... fix me.
	if os.path.exists(tmp_control_file + '.state'):
		os.remove(tmp_control_file + '.state')
	shutil.copyfile(os.path.abspath(sys.argv[1]), tmp_control_file)
else:
	if not os.path.exists(tmp_control_file):
		sys.exit(0)

# JOB: instantiate the job object ready for the control file.
job = job.job(tmp_control_file);

try:
	# Load in the users control file, may do any one of:
	#  1) execute in toto
	#  2) define steps, and select the first via next_step()
	execfile(tmp_control_file)

	try:
		init = step_init
	except NameError:
		pass
	else:
		job.step_engine([step_init])

	# If we get here, then we assume the job is complete and good.
	job.complete(0)

except JobContinue:
	sys.exit(5)

except JobError, instance:
	print "JOB ERROR:" + instance.args[0]
	job.complete(1)

except:
	raise
