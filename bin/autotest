#!/usr/bin/python2.3
#
# autotest <control file> - run the autotest control file specified.
#
import os, sys, shutil
import job, kernel, test
from error import *
from autotest_utils import *

# Use the name of the binary to find the real installation directory
# aka $AUTODIR.  Update our path to include the $AUTODIR/bin/tests
# directory and ensure we have $AUTODIR in our environment.
autodirbin = os.path.abspath(os.path.dirname(sys.argv[0]))
autodir = os.path.dirname(autodirbin)

##print 'AUTODIRBIN: ' + autodirbin
##print 'AUTODIR: ' + autodir

sys.path.insert(0, autodir + '/tests')
sys.path.insert(0, autodirbin)

os.environ['AUTODIR'] = autodir
os.environ['AUTODIRBIN'] = autodirbin

def usage():
	os.stderr.write("Usage: autotest [--continue] <control file>\n");
	sys.exit(1)

# Usage check.
if len(sys.argv) < 2:
	usage()

# A multi-phase job is continued using the --continue option.
cont = 0
if sys.argv[1] == '--continue':
	sys.argv.pop(1)
	cont = 1
	
# Check for a control file.
if len(sys.argv) != 2:
	usage()

control = sys.argv[1]
state = sys.argv[1] + '.state'

# Check that the control file is valid
if not os.path.exists(control):
	os.stderr.write(control + ": control file not found\n")
	sys.exit(1)


# When continuing, the job is complete when there is no state file,
# ensure we don't try and continue.
if cont == 1 and not os.path.exists(state):
	sys.exit(1)
if cont == 0 and os.path.exists(state):
	os.unlink(state)

# JOB: instantiate the job object ready for the control file.
job = job.job(control);

try:
	# Load in the users control file, may do any one of:
	#  1) execute in toto
	#  2) define steps, and select the first via next_step()
	execfile(control)

	try:
		init = step_init
	except NameError:
		pass
	else:
		job.step_engine([step_init])

	# If we get here, then we assume the job is complete and good.
	job.complete(0)

except JobContinue:
	sys.exit(5)

except JobError, instance:
	print "JOB ERROR:" + instance.args[0]
	job.complete(1)

except:
        # Ensure we cannot continue this job, it is in rictus.
	if os.path.exists(state):
		os.unlink(state)
	raise
